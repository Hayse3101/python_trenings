from fractions import Fraction
from decimal import Decimal
from datetime import time, date, datetime
from threading import *
from time import sleep

# ---------------------------------- Глава 1 ----------------------------------
# ---------------------------- Знакомство с Python ----------------------------

""" Первая программа """
print("Hello World!")  # <- Функция для вывода переданных аргументов

""" Знакомство с переменными """
txt1 = "Язык программирования Python"  # <- Переменная с текстовым значением
num1 = 123  # <- Переменная с целочисленным значением

print(txt1)  # <- Отображение значение переменной txt
print(num1)
print("Текст:", txt1)  # <- Отображение значение переменной txt

""" Ввод значения в программу """
name1 = input("Как вас зовут? ")  # <- Считывание текстового значения
age1 = int(input("Сколько вам лет? "))  # <- Считывание числового значения

print(f"Добрый день, {name1}! Ваш возраст {age1}!")  # <- Отображение считанных значений

""" Функция eval() """
txt2 = "(2+3) / 0.25 - 4 * 2.1"  # <- Текстовое представление для команды
print(f"{txt2} = {eval(txt2)}")  # <- Отображение выражения и вычисление результата

res1 = input("Введите выражение: ")  # <- Считывание выражения для вычисления
print(f"Значение выражения: {eval(res1)}")  # <- Отображение значение выражения

print(f"Результат: {eval(txt := "2 + 2")}")  # <- Код просто такю

""" Знакомство со списками """
nums1 = [5, 10, 1, 60, 25, 3]  # <- Список из чисел:
#  Операции со списком
print(f"Список из чисел: {nums1}")
print(f"Длина списка: {len(nums1)}")
print(f"Первый элемент: {nums1[0]}")
print(f"Последний элемент: {nums1[-1]}")
print(f"Наибольшее значение: {max(nums1)}")
print(f"Наименьшее значение: {min(nums1)}")
print(f"Сумма: {sum(nums1)}")
print(f"Список в обратном порядке: {list(reversed(nums1))}")
print(f"Сортировка по возрастанию: {sorted(nums1)}")
print(f"Сортировка по убыванию: {sorted(nums1, reverse=True)}")
nums1[1] = "текст"
print(f"Получение среза: {nums1[1: len(nums1) - 1]}")
nums1[1:-1] = ["A", "B"]
print(f"После замены элементов: {nums1}")
nums2 = list(range(5, 10))  # <- Список чисел от 5 до 10
nums2[2:4] = []  # <- Удаление элементов из списка
del nums2[len(nums2) - 1]  # <- Удаление последнего элемента
nums3 = [2 * k + 1 for k in range(5)]  # <- Генератор нечётных чисел
symbs1 = list("Python")  # <- Список из символов создаётся на основе текста

""" Знакомство с условным оператором """
number1 = int(input("Введите целое число: "))  # <- Считывание целого числа
if number1 % 2 == 0:  # <- Если число - чётное
    print("Вы ввели четное число.")
else:  # <- Если чесло - нечётное
    print("Вы ввели нечётное число.")

""" Знакомство с оператором цикла """
n1 = int(input("Укажите верхнюю границу суммы: "))  # <- Считывание верхней границы суммы
s1 = 0  # <- Начальное значение суммы
k1 = 0  # <- Начальное значение индексной переменной

while k1 < n1:  # <- Оператор цикла для вычесления суммы
    k1 += 1  # <- Увелечение значения индексной переменной на единицу
    s1 += k1  # <- Прибавление слагаемого к сумме

print(f"Сумма чисел от 1 до {n1} равна {s1}")  # <- Отображение результата

n2 = input("Укажите количество слагаемых: ")
txt3 = "1"
k2 = 1
while str(k2) != n2:
    k2 += k2
    txt = txt + "+" + str(k2)

print(f"txt = {eval(txt)}")

""" Знакомство с функциями """


def show(txt4):  # <- Функция для отображения букв из переданного
    symbs2 = sorted(list(txt4))  # <- Преобразование текста в список и его сортировка
    print(symbs2)  # <- Отображение содержимого списка


show("Python")  # <- Вызов функции


def sqsum(n):  # <- Функция для вычисления суммы квадратов натуральных чисел
    nums = [k * k for k in range(1, n + 1)]  # <- Создание списка из квадратов натуральных чисел
    return sum(nums)  # <- Фозвращение результата функции


m1 = 10  # <- Переменная с числовым значением
print(f"Сумма квадратов чисел от 1 до {str(m1)} : {sqsum(m1)}")  # <- Вызов функции для вычисления суммы квадратов чисел

# ---------------------------------- Глава 2 ----------------------------------
# ----------------------------- Основные операции -----------------------------
# ------ Оператор цикла while ------
""" Общий шаблон оператора цикла while
 while условие: 
        команды
 else:
        команды
"""

# -- 2.1. Отображение состава чисел --
number1 = int(input("Введите число: "))  # <- Вводится число
while number1 > 0:  # <- Пока числобольше нуля
    digit = number1 % 10  # <- Последняя цифра в числе
    print(f"| {str(digit)} ", end="")  # <- Отображение цифры
    number1 = number1 // 10  # <- Отбрасывается поледняя цифра в числе
print("|")  # <- Отображается последний результат
# --------------------------------

# -- 2.2. Простые числа --
number2 = int(input("Введите число: "))  # <- вводится число
num4 = number2 // 2  # <- Врехняя граница для делителя
k1 = 2  # <- Начальное значение делителя
while k1 <= num4:  # <- Поиск делителя числа
    if number2 % k1 == 0:  # <- Если число делится на k
        print("Число не является простым")
        break  # <- Завершение оператора цикла
    else:  # <- Если условие ложно
        k1 += k1  # <- Увеличивается значение делителя
else:  # <- Блок выполняется, если не выполнена инструкция break
    print("Это простое число")

print("Проверка завершена")  # <- Сообщение отображается всегда
# --------------------------------

# -- 2.3. Простые числа --
number3 = int(input("Введите число: "))  # <- Вводится число
print("Делится на", 1)  # <- Сообщение о первом делителе числа
k2 = 1  # <- Начальное значение для детлиетля
while k2 < number3 // 2:  # <- Поиск делителей числа
    k2 += 1  # <- Значение делителя увеличивается на единицу
    if number3 % k2 != 0:  # <-  Если k не является делителем числа
        continue  # <- Завершение текущего цикла
    print(f"Делится на {k2}")
print(f"Делится на {number3}")
# --------------------------------

# ------ Оператор цикла for ------
""" Шаблон вызова оператора for 
 for переменная in список:
        команды
"""
# -- 2.5. Перебор элементов списка --
colors = [  # <- Список с текстовыми элементами
    "Синий",
    "Желтый",
    "Зеленый",
]

print(colors)  # <- Отображение содержимого списка
for s in colors:  # <- Перебор элементов списка
    print(f"{s} -> {len(s)}")
# --------------------------------

# -- 2.6. Числа Фибоначчи --
n = 15  # <- Количествов последовательности
a, b = 1, 1  # <- Первые два числа
print(a, b, end=" ")  # <- Отображение первых двух чисел
for _ in range(n - 2):  # <- За каждый цикл вчисляется одно новое число
    a, b = b, a + b  # < - Вычисление нового числа в последовательности
    print(b, end=" ")  # <- Отображение нового числа

""" Шаблон вызова оператора for с блоком else: 
 for переменная in список:
        команды
 else:
        команды
"""
# --------------------------------

# -- 2.7. Поиск букв в тексте --
mytext = input("Введите текст для проверки: ")  # <-Текст для поиска букв
symbs2 = ['а',  # <- Буква для поиска
          'у',
          'я',
          ]
print(f"Ищем такие буквы: {symbs2}")

for s in symbs2:  # <- Поиск букв
    if s in mytext:  # <- Если буква найдена
        print("В тексте есть буква '" + s + "'")
        break  # <- Завершение оператора цикла
    else:  # <- Если буквы нет
        print("В тексте нет буквы '" + s + "'")
else:  # <- Блок else оератора цикла
    print("Таких букв в тексте нет")
print("Поиск завершен")  # <- Последнее сообщение программы
# --------------------------------

# -- 2.8. Решение линейного уравнения --
a1, b1 = eval(input("Введите (через запятую) два числа: "))
# 195 Проверка тива введенных параметров
if (type(a1) == int or type(a1) == float) and (type(b1) == int or type(b1) == float):
    print(f"Уравнение {str(a)}x = {str(b)}")
    if a != 0:  # <- Если первый параметр ненулевой
        print(f"Решение x = {str(b / a)}")
    else:  # <- Если первый параметр нулевой
        if b != 0:  # <- Если второй параметр нулевой
            print("Решений нет!")
        else:  # <- Если оба параметра нулевst
            print("Решение - любое число!")

else:  # <- Если параметры не числовые:
    print("Введены некорректные значения!")
    raise SystemExit(0)  # <- Завершение выполнения программы
print("Поиск решения завершен.")
# --------------------------------

""" Ещё один шаблон условных конструкция
 if условие:
    команды
 elif условие:
    команды
 ...
 elif условие:
    команды
 else:
    команды
"""

# -- 2.9. Ещё один способ решить уравнение --
a1, b1 = eval(input("Введите (через запятую) два числа: "))
# 195 Проверка тива введенных параметров
if (type(a1) != int and type(a1) != float) or (type(b1) != int and type(b1) != float):
    print("Введены некорректные значения!")
    raise SystemExit(0)  # <- Завершение выполнения программы
elif a != 0:  # <- Если первый параметр ненулевой
    txt4 = "Решение x = " + str(b / a)
elif b != 0:  # <- Если второйпараметр ненулевой (при нулевом первом)
    txt4 = "Решений нет!"
else:  # <- Если оба параметра нулевst
    print("Решение - любое число!")

print(f"Уравнение {str(a)}x = {str(b)}")  # <- Вид уравнения
print(txt4)  # <- Результат поиска корня
print("Поиск решения завершен.")
# --------------------------------

# -- 2.10. Индетификация числа --
res1 = "Это число "  # <- Текстовая переменная
txt5 = input("Введите название числа: ")  # <- Вводится текст
txt5 = txt5.lower()  # <- Преоразование в нижний регистр
if txt5 == "один" or txt5 == "единица":  # <- Индентификация числа
    res1 += "1"
elif txt5 == "два" or txt5 == "двойка":
    res1 += "2"
elif txt5 == "три" or txt5 == "тройка":
    res1 += "3"
else:
    res1 += "не идентифицировано"
print(res1)  # <- Результат Индентификации
# --------------------------------

# ------ Тернарный оператор ------
""" Синтаксис тернарного оператора 
- значение if условие else значение 
"""

# -- 2.11. Проверка числа на четность/нечетность --
num5 = int(input("Введите целое число: "))  # <- Вводится число
res2 = "четное" if num5 % 2 == 0 else "нечетное"  # <- Использование тернарного оператора
print(f"Это {res2} число")
# --------------------------------

# -- 2.12 . Значения разных типов и тернарный оператор --
val1 = eval(input("Введите выражение: "))  # <- Вводится выражение
a, b = (val1[0], val1[-1] if type(val1) == str else (val1, type(val1)))  # <- Используется тернарный оператор
print(a)  # <- Значения переменных
print(b)  # <- Значения переменных
# --------------------------------

# ------ Обработка исключительных ситуаций ------
""" Общий шаблон для конструкции try-except
 try:
    команды
 except:
    команды
"""

# -- 2.13. Знакомство с обработкой исключений --
print("Обработка исключений")
try:  # <- Контролируемый код
    num6 = int(input("Введите целое число: "))
    print(f"Вы ввели число {str(num6)}")
except:  # <- Обработка исключения
    print("Нужно было ввести целое число!")
print("Спасибо за сотрудничество!")
# --------------------------------
""" Шаблон try-except
 try:
    команды
 except Тип_ошибки:
    команды
 ...
 except Тип_ошибки:
    команды
"""

# -- 2.14. Обработка ошибок разных типов --
print("Операции со списком чисел...")
try:  # <- Контролируемый код
    nums4 = eval(input("Введите числовой список: "))
    print(f"Получено значение: {str(nums4)}")
    a2 = int(nums4[0])
    b2 = int(nums4[3])
    print(f"{str(a2)} / {str(b2)} = {str(a2 / b2)}")
except ValueError:  # <- Обработка исключений ValueError
    print("ValueError: ошибка при преобразовании!")
except ZeroDivisionError:  # <- Обработка исключений ZeroDivisionError
    print("ZeroDivisionError: попытка деления на ноль!")
except TypeError:  # <- Обработка исключений TypeError
    print("TypeError: недопустимая операция!")
except IndexError:  # <- Обработка исключений IndexError
    print("IndexError: неверный индекс элемента!")
except SyntaxError:  # <- Обработка исключений SyntaxError
    print("SyntaxError: невозможно вычислить выражение!")
except NameError:  # <- Обработка исключений NameError
    print("NameError: неверный индетификатор!")
print("Завершение программы.")
# --------------------------------

# -- 2.15. Ещё один способ обработки ошибок --
try:  # <- Контролируемый код
    nums4 = eval(input("Введите числовой список: "))
    print(f"Получено значение: {str(nums4)}")
    a2 = int(nums4[0])
    b2 = int(nums4[3])
    print(f"{str(a2)} / {str(b2)} = {str(a2 / b2)}")
except ZeroDivisionError:  # <- Обработка исключений ZeroDivisionError
    print("ZeroDivisionError: попытка деления на ноль!")
except IndexError:  # <- Обработка исключений IndexError
    print("IndexError: неверный индекс элемента!")
except:
    print("Что-то пошло не так!")
print("Завершение программы.")
# --------------------------------

# ---------------------------------- Глава 3 ----------------------------------
# ----------------------------- Списки и кортежи ------------------------------
# ------ Знакомство с кортежами ------
# Разные способы создания кортежей
Alpha1 = (5, 10, 15, "двадцать")
Bravo1 = 100, ['один', 'два', 'три'], 200
Charlie1 = tuple([1, 2, 3, (4, 5, 6, 7, 8, 9)])
Delta1 = tuple("ABCDEF")
Echo1 = tuple(2 ** k for k in range(11))

# Считывание значений элементов и получение среза:
print(f"Alpha: {Alpha1}")
print(f"Элементов: {len(Alpha1)}")
print(f"Первый: {Alpha1[0]}")
print(f"Последний: {Alpha1[-1]}")
print(f"Bravo: {Bravo1}")
print(f"Элементов: {len(Bravo1)}")
print(f"Bravo[1]: {Bravo1[1]}")
print(f"Bravo[1][2]: {Bravo1[1][2]}")
print(f"Charlie: {Charlie1}")
print(f"Элементов: {len(Charlie1)}")
print(f"Charlie[3]: {Charlie1[3]}")
print(f"Charlie[3][1:4]: {Charlie1[3][1:4]}")
print(f"Delta: {Delta1}")
print(f"Элементов: {len(Delta1)}")
print(f"Delta[-3:]: {Delta1[-3:]}")
print(f"Echo: {Echo1}")
Foxtrot1 = tuple(Echo1[k] for k in range(len(Echo1)) if k % 2 == 0)
print(f"Foxtrot: {Foxtrot1}")
Golf1 = Echo1[2:5]
print(f"Golf: {Golf1}")

# -- 3.2 Операции со списками --
# Создание списков:
A1 = [10, 20, 30]
print(f"A: {A1}")
B1 = ["Python", [1, 2]]
print(f"B: {B1}")
# Вычисление суммы списков
C1 = A1 + B1
print(f"C: {1}")
# Добавление элементов в конец списка
C1 += [100]
print(f"C: {C1}")
# Удаление элемента списка
C1[1:2] = []
print(f"C: {C1}")
# Добавление элемента в начало списка
C1 = [200] + C1
print(f"C: {C1}")
# Замена нескольких элементов в списке
C1[:3] = ["A", "B"]
print(f"C: {C1}")
# Вставка элементов в список
C1[2:2] = [8, 9]
print(f"C: {C1}")
# Присваивание значение элементоу списка
C1[2:3] = [7]
print(f"C: {C1}")
# --------------------------------

# -- 3.3 Операции со списками --
# Создание кортежей
A2 = (10, 20, 30)
print(f"A: {A2}")
B2 = ("Python", (1, 2))
print(f"B: {B2}")
# Вычисление суммы кортежей
C2 = A2 + B2
print(f"C: {C2}")
# "Добавление" элемента в конец кортежа
C2 += (100,)
print(f"C: {C2}")
# "Удаление" элемента кортежа
C2 = C2[:1] + C2[2:]
print(f"C: {C2}")
# "Замена" нескольких элементов в кортеже
C2 = ("A", "B") + C2[3:]
print(f"C: {C2}")
# "Вставка" элементов в кортеж
C2 = C2[:2] + (8, 9) + C2[2:]
print(f"C: {C2}")
# "Присваение" значения элементу кортежа
C2 = C2[:2] + (7,) + C2[3:]
print(f"C: {C2}")
# --------------------------------

# ------ Создание выборки на основе списков и кортежей ------
# -- 3.4 Создание выборки --
A3 = tuple(k for k in range(1, 21) if k % 3 != 0)  # <- Кортеж чисел
print(A3)
B3 = [2 ** (k // 2) if k % 2 == 0 else 3 ** (k // 2) for k in range(15)]  # <- Список чисел
print(B3)
C3 = [0 if k == 0 or k == 1 else k ** 2 for k in range(13) if not k in [2, 5, 7]]  # <- Список чисел
print(C3)
Alpha2 = A3[::-1]  # <- Кортеж в обратном порядке
print(Alpha2)
Bravo2 = B3[::2]  # <- Элементы выбираются "через один", начиная со второго
print(Bravo2)
Charlie2 = C3[1::2]  # <- Элементы выбераются "через один", начиная со второго
print(Charlie2)
# --------------------------------

# -- 3.5 Умножение списков и кортежей на число --
Alpha1 = 5 * [0]
print(Alpha1)
Bravo1 = (1,) * 3
print(Bravo1)
Charlie1 = [1, 2] * 3
print(Charlie1)
Delta1 = [[1, 2]] * 3
print(Delta1)
Echo1 = 4 * (1, [2, 3])
print(Echo1)
Foxtrot1 = ([1] * 2) * 3
print(Foxtrot1)
Golf1 = ([1] * 2,) * 3
print(Golf1)
# --------------------------------

# ------ Вложенные списки и кортежи ------
# -- 3.6 Создание вложенных списков --
# Импорт функций для генерирования случайных чисел
from random import *


def show(A):  # <- Функция для отображения вложенного списка
    for a in A:
        for s in a:
            print(s, end='')
        print()


def rands(m, n):  # <- # Функция для создания вложенного списка из слючайных чисел
    res = [[randint(0, 9) for _ in range(n)] for _ in range(m)]
    return res


def symbs(m, n):  # <- Функция для создания вложенного списка из букв
    val = 'A'
    res = [['' for _ in range(n)] for _ in range(m)]

    for i in range(m):
        for j in range(n):
            res[i][j] = val
            val = chr(ord(val) + 1)
    return res


A4 = [[(j + 1) * 10 + i + 1 for i in range(5)] for j in range(3)]  # <- Создание вложенного списка
print(A4)
show(A4)  # <- Отображение вложенного списка
seed(2019)  # <- Инициализация генератора случайных чисел
B4 = rands(3, 4)  # <- Список случайных чисел
print(f"Список B4: {B4}")
show(B4)  # <- Отображение вложенного списка
C4 = symbs(3, 5)  # <- Список с буквами
print(f"Список С4: {C4}")
show(C4)  # <- Отображение вложенного списка
size = [3, 5, 4, 6]  # <- Список определяет количество строк во вложенном списке
D1 = [['*' for k in range(s)] for s in size]  # <- Создание влоэенного списка
print(f"Список D1: {D1}")
show(D1)  # <- Отображение вложенного списка
# --------------------------------

# -- 3.7 Присваивание списков --
A5 = [1, 3, 5]  # <- Исходный список
B5 = A5  # <- Присваивание списков
# Изменение значение элементов
B5[1] = "Python"
A5[2] = (10, 20)
# Проверка результата
print(A5)
print(B5)
# --------------------------------

# -- 3.8 Создание поверхностной копии --
A6 = [1, 3, [10, 20], "Python", [40, 50]]  # <- Исходный список
B6 = A6[:]  # <- Создание поверхностной копии списка
C5 = A6.copy()
print(f"Исходные значения: A - {A6}, B - {B6}, C - {C5}")
# Внесение изменений в исходный список
A6[0] = [100, 200]
A6[2][1] = 300
A6[3] = "Java"
A6[4] = 90
C5[4][1] = "C++"
print(f"После внесения изменений: A - {A6}, B - {B6}, C - {C5}")
# --------------------------------

# -- 3.9 Создание полной копии --
from copy import deepcopy, copy  # < -- Импорт функции для создания полной копии

A7 = [1, 3, [10, 20], 'Python', [40, 50]]  # <- Исходный код
B7 = deepcopy(A6)  # <- Создание полной комии списка
print(f"Исходные значения: A - {A7}, B - {B7}")
# Внесение изменений в исходный список
A7[0] = [100, 200]
A7[2][1] = 300
A7[3] = "Java"
A7[4] = 90
print(f"После внесения изменений: A - {A7}, B - {B7}")
# --------------------------------

# ------ Функции и методы для работы со списками ------
# -- 3.10 Вставка и удаление элементов --
n = 10  # <- Размер списка
A8 = [1, 1]  # <- Начальное значение для списка
for _ in range(n - 2):  # <- Заполнение списка
    A8.append(A8[-1] + A8[-2])

print(f"A: {A8}")  # <- Проверка содержимого списка
A8.remove(max(A8))  # <- Удаление наибольшего элемента в списке
print(f"A: {A8}")  # <- Проверка содержимого списка
A8.remove(min(A8))  # <- Удаление наименьшего элемента в списке
print(f"A: {A8}")  # <- Проверка содержимого списка
A8.insert(0, A8[0] + A8[1])  # <- Добваление элемента в начало списка
print(f"A: {A8}")  # <- Проверка содержимого списка
B8 = []  # <- Пустой список
for _ in range(len(A8) // 2):  # <- Часть элементов одного списка переносится в другой
    B8.insert(0, A8.pop(-1))

print(f"A: {A8}")  # <- Проверка содержимого списка
print(f"B: {B8}")  # <- Проверка содержимого списка
A8.append(B8)  # <- Добавление элемента в конец списка
print(f"A: {A8}")  # <- Проверка содержимого списка
A8.pop(-1)  # <- Удаление последнего элемента в списке
print(f"A: {A8}")  # <- Проверка содержимого списка
A8.extend(B8)  # <- Добавление элементов в список
print(f"A: {A8}")  # <- Проверка содержимого списка
# --------------------------------

# -- 3.11 Поиск и подсчёт количества элементов --
from random import *  # <- Подключение функция для генерирования случайных чисел

seed(2019)  # <- Инициализация генератора случайных чисел
A9 = [randint(10, 20) for _ in range(15)]  # <- Создание списка из слючайных чисел
print(f"A: {A9}")  # <- Cодержимое списка
for a in range(min(A9), max(A9) + 1):  # <- Подсчёт элементов с разными значениями
    print(f"{a} - {A9.count(a)}")

# Наибольшее, наименьшее и среднее значения
print("Наименьший: ")
print(f"A[{A9.index(min(A9))}] = {min(A9)}", sep="")
print("Наибольший")
print(f"A[{A9.index(max(A9))}] = {max(A9)}", sep="")
print(f"Среднее: {sum(A9) / len(A9)}")
B9 = sorted(A9)  # <- Сортировка списка
A9.sort(reverse=True)  # <- Сортировка списка
print(f"A: {A9}")  # <- Проверка содержимого списка
print(f"B: {B9}")  # <- Проверка содержимого списка
# --------------------------------

# ---------------------------------- Глава 4 ----------------------------------
# ----------------------------- Множества и словари ------------------------------
# ------ Знакомство с множествами ------

# -- 4.1 Создание множеств --
A10 = {10, 50, 20, 10, 50}  # <- Создание множества
B10 = set([6, 2, 6, 0, 4, 0])  # <- Создание множества
C10 = set("Hello World!")  # <- Создание множества
# Проверка содержимого множест
print(f"А: {A10}")
print(f"Элементов: {len(A10)}")
print(f"А: {B10}")
print(f"Элементов: {len(B10)}")
print(f"А: {C10}")
print(f"Элементов: {len(C10)}")
# --------------------------------

# -- 4.2 Генерирование разных случайных чисел --
seed(2019)  # <- Инициализация генератора случайных чисел

count1 = 10  # <- Количсетво разных случайных чисел
nums5 = set()  # <- Создание пустого множества
while len(nums5) < count1:  # <- Генерирование случайных чисел
    nums5.add(randint(1, count1 + 5))

print(f"Результат: {nums5}")  # <- Отображение результата
# --------------------------------

# -- 4.3 Операции с множествами --
# Создание множеств
A11 = {2 * k + 1 for k in range(5)}
B11 = {2 * k for k in range(5)}
C11 = {2 * k + 1 for k in range(3, 8)}

# Содержимое множеств
print("Созданы множества: ")
print(f"A = {A11}")
print(f"B = {B11}")
print(f"C = {C11}")

# Объединение множеств
print("Объединение множеств: ")
print(f"A | B = {A11.union(B11)}")
print(f"B | A = {B11.union(A11)}")
print(f"A | C = {A11 | C11}")

# Пересечение множеств
print("Пересечение множеств: ")
print(f"A & B = {A11.intersection(B11)}")
print(f"A & C = {A11 & C11}")

# Разность множеств
print("Разность множеств: ")
print(f"A - C = {A11 - C11}")
print(f"C - A = {C11.difference(A11)}")

# Симметрическая разность множеств
print("Симметрическая разность множеств: ")
print(f"A ^ C = {A11 ^ C11}")
print(f"C ^ A = {C11.symmetric_difference(A11)}")

# Исходные множества
print("Исходные множества: ")
print(f"A = {A11}")
print(f"B = {B11}")
print(f"C = {C11}")
# --------------------------------

# -- 4.4 Изменение множеств --
# Создание множеств
A12 = {0, 5, 10, 15, 20}
B12 = {10, 15, 20, 25, 30}

# Содержимое множеств
print("Созданы множества: ")
print(f"A = {A12}")
print(f"B = {B12}")

# Пересечение множеств
print("Пересечение множеств A и B: ")
A12.intersection_update(B12)
print(f"A = {A12}")

# Объединение множеств
print("Объединение множеств {1, 20, 100}: ")
A12.update({1, 20, 100})
print(f"A = {A12}")

# Разность множеств
print("Разность множеств B и A: ")
B12.difference_update(A12)
print(f"B = {B12}")

# Симметрическая разность множеств
print("Симметрическая разность множеств B и {30, 35}: ")
B12.symmetric_difference_update({30, 35})
print(f"B = {B12}")

# --------------------------------

# -- 4.5 Использование операторов для изменения множеств --
A13 = {0, 5, 10, 15, 20}
B13 = {10, 15, 20, 25, 30}

print("Созданы множества: ")
print(f"A = {A13}")
print(f"B = {B13}")

print("Пересечение множеств A и B: ")
A13 &= B13
print(f"A = {A13}")

print("Объединение множеств {1, 20, 100}: ")
A13 |= {1, 20, 100}
print(f"A = {A13}")

print("Разность множеств B и A: ")
B13 -= A13
print(f"B = {B13}")

print("Симметрическая разность множеств B и {30, 35}: ")
B13 ^= {30, 35}
print(f"B = {B13}")

# --------------------------------

# -- 4.6 Сравнение множеств --
# Исходные множества
A14 = {1, 2}
B14 = {1, 2, 3}
C14 = {3, 2, 1}

# Содержимое множеств
print(f"A = {A14}")
print(f"B = {B14}")
print(f"C = {C14}")

# Сравнение множеств
print(f"A == B: {A14 == B14}")
print(f"A != B: {A14 != B14}")
print(f"B == C: {B14 == C14}")
print(f"B != C: {B14 != C14}")
print(f"A < B: {A14 < B14}")
print(f"A > B: {A14 > B14}")
print(f"B < C: {B14 < C14}")
print(f"B <= C: {B14 <= C14}")
print(f"B >= C: {B14 >= C14}")
print(f"B >= A: {B14 >= A14}")
# --------------------------------

# ------ Примеры использования множества ------
# -- 4.7 Состав числа --
number4 = int(input("Введите число: "))  # <- Считывание числа

if number4 < 0:  # <- Если число отрицательное
    number4 *= -1

digits = set()  # <- Создание пустое множество
if number4 == 0:  # <- Если был введен ноль
    digits.add(0)
else:  # <- Если число не равно нулю
    while number4 != 0:  # <- Перебор цифр в предствалении числа
        digits.add(number4 % 10)  # <- Последняя цифра в представлении числа
        number4 //= 10  # <- Последняя цифра

print("Число состоит из таких цифр: ")
for n in digits:  # <- Отображение результата
    print(n, end=" ")
print()  # <- Переход к новой строке

# --------------------------------

# -- 4.8 Общие буквы в тексте --
text0 = input("Первый текст: ")
A15 = set(text0)  # <- Первое множество
text0 = input("Второй текст: ")
B15 = set(text0)  # <- Второе множество
C15 = A15 & B15  # <- Общие буквы

# Результат
print(f"Буквы из первого текста: {A15}")
print(f"Буквы из второго текста: {B15}")
print(f"Общие буквы: {C15}")

# --------------------------------

# -- 4.9 Числа с заданными свойствами --
n3 = 50  # <- Верхняя граница для чисел
E1 = set(range(1, n3 + 3))  # <- Множество натуральных чисел
A16 = {s for s in E1 if s % 3 == 0}  # <- Множество чисел, которые делятся на 3
B16 = {s for s in E1 if s % 11 == 0}  # <- Множество чисел, которые делятся на 11
C16 = {s for s in E1 if s % 5 == 0}  # <- Множество чисел, которые делятся на 5
D0 = {s for s in E1 if s % 7 == 0}  # <- Множество чисел, которые делятся на 7

N0 = (A16 | B16) - (C16 | D0)  # <- Множество чисел, которые делятся на 3 и 11, но не делятся на 5 и 7
print(N0)  # <- Отображение результата
# --------------------------------

# ------ Знакомство со словарями ------
# -- 4.10 Знакомство со словарями --
nums6 = {100: "Сотня", 1: "единица", 10: "десятка"}

# Содержимое словаря
print(nums6)
print(f"1: {nums6[1]}")
print(f"10: {nums6[10]}")
print(f"100: {nums6[100]}")

# Операции со словарем
nums6[3] = "тройка"
nums6[10] = "десять"
nums6.pop(100)
print(nums6)

# Второй словарь
order0 = dict(Первый=1, Третий=3, Последний=10)

# Содержимое словаря
print(order0)
print(f"Первый: {order0["Первый"]}")
print(f"Третий: {order0["Третий"]}")
print(f"Последний: {order0["Последний"]}")

# Операции со словарем
order0["Последний"] = 12
del order0["Третий"]
order0["Пятый"] = 5
print(order0)
# --------------------------------

# -- 4.11 Другие способы создания словарей --
age2 = dict([["Кот Матроскин", 5], ["Пёс Шарик", 7], ["Дядя Фёдор", 12]])  # <- Создание словаря
for s in age2.keys():  # <- Перебор ключей
    print(f"{s}: {age2[s]}")

for v in age2.values():  # <- Перебор значений
    print(v, end=" ")
print()

color0 = dict([[(255, 0, 0), "Красный"], [(0, 255, 0), "Зеленый"], [(0, 0, 255), "Синий"]])  # <- Создание словаря

# Обращение к элементам словаря
color0[(255, 255, 0)] = "Жёлтый"
print(f"(255, 0, 0): ", color0[(255, 0, 0)])
print(f"(255, 255, 0): ", color0[(255, 255, 0)])
print(f"(0, 255, 0): ", color0.get((0, 255, 0)))
print(f"(0, 0, 255): ", color0.get((0, 0, 255), "Белый"))
print(f"(255, 255, 255): ", color0.get((255, 255, 255), "Белый"))

# --------------------------------

# -- 4.12 Генераторы словарей --
days0 = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"]  # <- Список со значениями ключей

# Создание словарей
week0 = {days0[s]: s for s in range(len(days0))}
myweek0 = {d: days0.index(d) for d in days0}

# Проверка результата
print(week0)
print(myweek0)

sqrs = {k: k ** 2 for k in range(1, 11) if k % 2 != 0}  # <- Создание ещё одного словаря
print(sqrs)  # <- Проверка результата

# --------------------------------

# ------ Операции со словарями ------
# -- 4.13 Создание словаря на основе словаря --
A17 = {"Начальный": 1, "Средний": 2, "Последний": 3}  # <- Исходный словарь
B17 = dict(A17)
C17 = A17.copy()
D2 = {k: v * 10 for k, v in A17.items()}  # <- Создание словаря на основе словаря

# Отображение результата
print(f"A = {A17}")
print(f"B = {B17}")
print(f"C = {C17}")
print(f"D = {D2}")
for k in A17:  # <- Изменение исходного словаря
    A17[k] *= 100

# Отображение результата
print("После изменения оригинала: ")
print(f"A = {A17}")
print(f"B = {B17}")
print(f"C = {C17}")
print(f"D = {D2}")

# --------------------------------

# -- 4.14 Полная поверхностная копия словаря --
A18 = {"один": 1, "два": "двойка", "три": [3, 4]}  # <- Исходный словарь

# Поверхностная копия словаря
B18 = dict(A18)
C18 = A18.copy()

# Полная копия словаря
D3 = deepcopy(A18)

# Отображение результата
print(f"A = {A18}")
print(f"B = {B18}")
print(f"C = {C18}")
print(f"D = {D3}")

# Изменение значений элементов исходного словаря
A18["два"] = 2
A18["три"][1] = 5

# Проверка результата
print(f"A = {A18}")
print(f"B = {B18}")
print(f"C = {C18}")
print(f"D = {D3}")

# --------------------------------

# -- 4.15 Некоторые операции со словарями --
# Создание словарей
A19 = dict(zip([1, 2, 3], ['K', 'L', 'M']))
B19 = dict.fromkeys([10, 20, 30], 'Z')

# Отображение результата
print(f"A = {A19}")
print(f"B = {B19}")

# Сравнение словарей
print(f"A == B: {A19 == B19}")
print(f"A != B: {A19 != B19}")

A19.update(B19)  # <- Добавление одного словаря к другому
print("Объединение словарей")
print(f"A = {A19}")

# Проверка содержимого словаря
print("Проверка содержимого словаря: ")
print((20, 'Z') in A19.items())
print(20 in A19)
print('Z' in A19)
print(5 not in A19)

A19.clear()  # <- Очистка словаря

# Проверка результата
print("Словарь после чистки: ")
print(f"A = {A19}")

# --------------------------------

# ---------------------------------- Глава 5 ----------------------------------
# ----------------------------- Работа с текстом ------------------------------
# ------ Текстовые литералы ------

# -- 5.1 Текстовые литералы --
A20 = "Язык 'Python' отличается от языка \"Java\"."
print(A20)
B20 = 'Язык "Java" отличается от языка \'C++\'.'
print(B20)
C20 = "Серый\tЖелтый\tКрасный\nСиний\tБелый\tЗеленый"
print(C20)
print("\\ Омар Хайями \\")
D4 = """ Зачем копить добро в пустыне бытия?
        Кто вечно жил среди нас? Таких не видел я.
         Ведь жизнь нам в долг дана, и то - на срок недолгий,
         А то, что в долг дано, не собственность твоя. """
print(D4)

# --------------------------------

# -- 5.2 Использование префиксов в литералах --
A21 = "\"Java\"\n\"Python\""  # <- Текстовый литерал без префикса
print(A21)
print(f"Символов: {len(A21)}")
B21 = r"\"Java\"\n\"Python\""  # <- Текстовый литерал с префиксом
print(B21)
print(f"Символов: {len(B21)}")
name1 = "Python"  # <- Переменная с текстовым значение
C21 = f"Язык {name1} - простой и понятный"  # <- Текстовый литерал с префиксом
print(C21)
C21 = f"Язык {name1!r} - простой и понятный"
print(C21)
num2 = 12.34567  # <- Переменная с числовым значением
txt6 = f"Число: {num2:9.3f}"  # <- Текстовый литерал с префиксом
print(txt6)
txt6 = f"Число: {num2:09.3f}"
print(txt6)
num3 = 42  # <- Новое числовое значение переменной
txt6 = f"Число: {num3:*>9d}"
print(txt6)
txt6 = f"Число: {num3:#09x}"  # <- Формат для отображения шестнадцатеричного числа
print(txt6)
txt6 = f"Число: {num3:9x}"
print(txt6)
txt6 = f"Число: {num3:*<9x}"
print(txt6)
txt6 = f"Число: {num3:*^#09o}"  # <- Формат для отображения восьмеричного числа
print(txt6)
txt6 = f"Число: {num3:#9b}"  # <- Формат для отображения двоичного числа
print(txt6)

# --------------------------------

# -- 5.3 Создание форматированного текста --
A22 = "Число {}, текст {} и снова число {}"
txt7 = A22.format(123, "Python", 321)
print(txt7)
txt7 = "Число {0} - это {0: b} или {0: x}".format(42)
print(txt7)
txt7 = "Код: {0:05d}, символ: {0:*^5c}".format(65)
print(txt7)
txt7 = "Число: {:_>+20.3E}".format(123.468)
print(txt7)
B22 = '{0:_{2}{1}s}'
num7 = 6
for k in range(1, num7 + 1):
    print(B22.format("*", k, ">"), end="")
    print(" " * (2 * (num7 - k)), end="")
    print(B22.format("*", k, "<"))

# --------------------------------

# ------ Основные операции с текстом ------
# -- 5.4 Базовые операции с текстом --
txt8 = "Hello Python"  # <- Исходный текст
print(txt8)
A23 = txt8[::-1]  # <- Текст в обратном порядке
print(A23)
B23 = txt8[:5]  # <- Первое слово в тексте
print(B23)
C23 = txt8[6:]  # <- Последнее слово в тексте
print(C23)

new_txt1 = ""  # <- Переменная с текстовым значением
delta1 = ord("a") - ord("A")  # <- Переменная с целочисленным значением
for s in txt8:  # <- Перебор символов в тексте
    if (ord(s) >= ord("a")) and (ord(s) <= ord("z")):  # <- Если буква в диапозоне от "a" до "z":
        s = chr(ord(s) - delta1)
    new_txt1 += s  # <- Добваление символа к тексту
print(new_txt1)  # <- Текст из больших букв

# --------------------------------

# ------ Методы для работы с текстом ------
# -- 5.5 Изменение регистра символа --
txt9 = "Язык PYTHON проще, чем язык JAVA!"
print(txt9)
print(txt9.upper())
print(txt9.lower())
print(txt9.swapcase())
print(txt9.title())
print(txt9.capitalize())

# --------------------------------

# -- 5.6 Подсчёт символов в тексте --
txt9 = input("Введите текст: ")
symb1 = input("Какую букву найти? ")
num7 = txt9.count(symb1)

if num7 == 0:
    print("Такой буквы в тексте нет!")
else:
    print(f"В тексте {num7} букв(ы) '{symb1}'")

# --------------------------------

# -- 5.7 Оперделение позиций символа в тексте --
txt10 = input("Введите текст: ")
symb2 = input("Какую букву найти: ")
num8 = txt.find(symb2)
L = []

while num8 != -1:
    L.append(num8)
    num8 = txt.find(symb2, num8 + 1)

if len(L) == 0:
    print("Такой буквы в тексте нет!")
else:
    print(f"Позиции буквы '{symb2}' в тексте: {L}")

# --------------------------------

# -- 5.8 Замена подстрок в тексте --
txt11 = "Мы изучаем язык Python"
print(txt10)
A24 = txt10.replace(" ", "_*_")
print(A24)
B24 = txt10.replace(" ", "\n")
print(B24)
C24 = txt10.replace(" ", " не ", 1).replace("Python", "Java")
print(C24)
D5 = txt10.replace("язык", "")
print(D5)

# --------------------------------

# -- 5.9 Формирование и разбивка теста --
A25 = ["Alpha", "Bravo", "Charlie"]
print(f"Список: {A25}")
B25 = ", ".join(A25)
print(f"Текст: {B25}")
C25 = B25.split(", ")
print(f"Снова список: {C25}")
txt12 = """Прошли года
И в свете лет
Есть мудрость
А вот счатья нет"""
print(txt12)
D6 = txt12.splitlines()
print(D6)

# --------------------------------

# -- 5.10 Выравние текста --
txt13 = "PYTHON"
num9 = 20
A26 = txt13.ljust(num9, "_")
B26 = txt13.center(num9)
C26 = txt13.rjust(num9, "*")
print(f"| {A26} |")
print(f"| {B26} |")
print(f"| {C26} |")

# --------------------------------

# ------ Примеры работы с текстом ------
# -- 5.11 Попарный обмен символами --
txt14 = input("Введите текст: ")  # <- Исзодный текст
new_txt2 = ""  # <- Новый текст
num10 = 0  # <- Индекс символа
while num10 < len(txt14) - 1:  # <- Перебор символов
    new_txt2 += txt14[num10 + 1] + txt14[num10]  # <- Добавление символов в текст
    num10 += 2  # <- Новое значение индекс

if num10 < len(txt14):  # <- Если в исходном тексте остался символ
    new_txt2 += txt14[num10]
print(f"Результат: {new_txt2}")

# --------------------------------

# -- 5.12 Шифрование текста --
txt15 = input("Ваш текст: ")  # <- Исходный текст

# Переменные
new_txt3 = ""
m = ord("а")
n = ord("я")
M = ord("А")
N = ord("Я")

# Создание шифра
for s in txt15:
    k = ord(s)
    if (m <= k < n) or (k > M and k > N):
        s = chr(k + 1)
    elif k == n:
        s = chr(m)
    elif k == N:
        s = chr(M)

    new_txt3 += s

print(f"Шифр: {new_txt3}")  # <- Проверка рещультата

# --------------------------------

# -- 5.13 Средняя длина слова --
txt16 = input("Введите текст: ")  # <- Исходный текст
txt16 = txt16.lower()  # <- Все буквы маленькие
print(txt16)  # <- Результат преобразование
L1 = txt.split(" ")  # <- Ращбивка текста на подстроки
print(L1)  # Результат разбивки

# Переменные
s = 0
n = 0

for k in range(len(L1)):  # <- Перебор элементов  списка
    w = L1[k].strip(".,:;-!?")
    if len(w) != 0:  # <- Если текст непустой
        print(w.ljust(12), "-", len(w))  # <- Отображение слова и его длины
        s += len(w)  # <- Сумма букв в словах
        n += 1  # <- Количество слов

s /= n  # <- Среднее значение
print(f"Средняя длина: {s}")


# --------------------------------

# ---------------------------------- Глава 6 ----------------------------------
# --------------------------------- Функции -----------------------------------
# ------ Объявление и вызов функции ------

# -- 6.1 Создание и использование функций --


def next_day():  # <- Функция без аргументов не возваращает результат
    txt0 = input("Какой сегодня день? ")
    txt0 = txt0.lower().strip()
    if txt0 == "Понидельник":
        new_txt0 = "Вторник"
    elif txt0 == "Вторник":
        new_txt0 = "Среда"
    elif txt0 == "Среда":
        new_txt0 = "Четверг"
    elif txt0 == "Четверг":
        new_txt0 = "Пятница"
    elif txt0 == "Пятница":
        new_txt0 = "Суббота"
    elif txt0 == "Суббота":
        new_txt0 = "Воскресенье"
    elif txt0 == "Воскресенье":
        new_txt0 = "Понидельник"
    else:
        print("Нет такого дня недели!")
        return

    print(f"Завтра - {new_txt0}")


def get_name():  # <- Функция без аргументов возваращает результат
    name = input("Добрый день! Как вас зовут? ")
    if name.strip(".,:;!?_") == "":
        name = "Мистер Икс"
    return name


def hello():  # <- Функция без аргументов не возваращает результат
    name = get_name()
    print(f"Приятно познакомиться, {name}!")
    next_day()


hello()


# --------------------------------

# -- 6.2 Функции для работы с данными разных типов --


def show0(L, symb):  # <- Функция для отображения содержимого списков, множест, текста и словарей
    for s in L:
        print(symb, s, sep="", end="")
    print(symb)


# Исходные данные
A27 = [1, 2, 3, 4, 5]
B27 = {'A', 'B', 'C', 'D'}
C27 = "Python"
D7 = {'A': 1, 'B': 2, 'C': 3}

# Вызов функции
show0(A27, "|")
show0(B27, "/")
show0(C27, "*")
show0(D7, "|")


def get_nums(n, state):  # <- Функция для создания списка чисел
    if type(n) != int:
        return []
    if state:
        L = list(2 * (k + 1) for k in range(n))
    else:
        L = list(2 * k + 1 for k in range(n))
    return L


# Вызов функции
print(get_nums(10, True))
print(get_nums(8, False))
print(get_nums(12.5, True))


def get_symbs(n):  # <- Функция для создания множества случайных букв
    if n > 10 or n < 1:
        num = 10
    else:
        num = n

    S = set()
    Nmin = ord("A")
    Nmax = ord("Z")

    while len(s) < num:
        S.add(chr(randint(Nmin, Nmax)))

    return S


seed(2019)  # <- Инициализация генертора случайных чисел
# Вызов функции
print(get_symbs(7))
print(get_symbs(-5))
print(get_symbs(15))


# --------------------------------

# -- 6.3 Имя функции как переменная --
# Функции


def alpha0():
    print("Это Alpha!")


def bravo0():
    print("Это bravo!")


def hello0():
    print("А это hello!")


num = 123  # <- Переменная с целочисленным значением
# Вызов функции и проверка значения переменной
print("Сначала было так: ")
alpha0()
bravo0()
hello0()
print(f"num = {num}")
# Изменение значений
alpha0, bravo0 = bravo0, alpha0
num = hello0
hello = 321
# Вызов "функций" и проверка значения "переменной"
print("А стало так: ")
alpha0()
bravo0()
hello0()
print(f"hello = {hello0}")


# --------------------------------

# ------ Именованные аргументы функции ------
# -- 6.4 Передача аргументов по позии и по имени --


def show1(first, second, third):  # <- Функция с тремя аргументами
    print(f"[1] Первый аргумент - {first}")
    print(f"[2] Второй аргумент - {second}")
    print(f"[3] Третий аргумент - {third}")


show1(1, 2, 3)
show1(second="B", third="C", first="A")
show(1, third=3, second=2)


# --------------------------------

# -- 6.5 Механизм передачи аргументов --
# Функции


def shift(val):
    print("Функция shift()")
    print(f"Исходное значение: {val}")
    val = ["A", "B", "C"]
    print(f"Конечное значение: {val}")


def change(val):
    print("Функция change()")
    print(f"Исходное значене: {val}")
    if type(val) == list:
        for k in range(len(val)):
            val[k] += 1
    else:
        val += 1
    print(f"Конечное значение: {val}")


num11 = 100  # <- Переменная
L2 = [10, 20, 30]  # <- Список
# Вызов функций
print(f"Переменная num={num11}")
change(num11)
print(f"Переменная num={num11}")
print(f"Список L2={L2}")
shift(L2)
print(f"Список L2={L2}")
change(L2)
print(f"Список L2={L2}")


# --------------------------------

# ------ Значения аргументов по умполчанию ------
# -- 6.6 Значения аргуметов по умолчанию --


def show2(first, second="Bravo", third="Charlie"):
    print(f"[1] - {first}")
    print(f"[2] - {second}")
    print(f"[3] - {third}")
    print("-" * 13)


# Вызов функции
show2("Alpha")
show2("A", "B", "C")
show2(10, 20)
show2(100, third=300)
show2(third="третий", first="первый")


# --------------------------------

# -- 6.7 Список как значенеи по умолчанию --


def show3(val=[0, 1, 2]):  # <-Значение по умолчанию для аргумента - список
    for k in range(len(val)):
        val[k] += 1
    print(val)


# Вызов функции
show3()
show3()
show3()


# --------------------------------

# ------ Функции с произвольным количеством аргуметов ------
# -- 6.8 Произвольное количество аргументов у функции --
# Функции с произвольным количеством аргуметов


def sqr_sum(*n):
    s = 0
    for i in n:
        s += a * a
    return s


def get_sum(*n):
    s = 0
    for a in n:
        if type(a) == int:
            s += a
    return s


def get_txt(*t):
    return " ".join(t)


# Вызов функций
print(f"Сумма квадратов: {sqr_sum(1, 3, 5)}")
print(f"Сумма квадратов: {sqr_sum(2, 4, 6, 8, 10)}")
print(f"Сумма чисел: {get_sum(2, 'A', 4, 'B', 6)}")
print(f"Сумма чисел: {get_sum(1, [2, 3], 4)}")
print(f"Сумма чисел: {get_sum()}")
print(f"Текст: {get_txt("Всем", "привет")}")
print(f"Текст: {get_txt('A', 'B', 'C', 'D')}")


# --------------------------------

# -- 6.9 Функция с разными аргументами --


def my_sum(n, *a, txt="Сумма чисел"):  # <- Функция с разными аргументами
    s = 0
    for m in range(len(a)):
        s += [m] ** n
    print(f"{txt}: {s}")


# Вызов функции
my_sum(1, 100, 200, 300)
my_sum(2, 10, 20, 30, txt="Сумма квадратов")


# --------------------------------

# ------ Локальные и глобальные переменные ------
# -- 6.10 Локальные и глобальные переменные --


def myfunction():  # <- В функции используются глобальные и локальные переменные
    global A28, B28  # <- Глобальные переменные
    # Присваивание значение переменным
    A28 = "Альфа"
    B28 = "Браво"
    D = "Дельта"

    # Проверка значений
    print(f"В функции: A = {A28}")
    print(f"В функции: B = {B28}")
    print(f"В функции: D = {D}")


# Глобальные переменные
A28 = "Alpha"
B28 = "Bravo"
D8 = "Delta"
C28 = "Charlie"

# Проверка значений переменных
print(f"До вызова функции: A = {A28}")
print(f"До вызова функции: C = {C28}")
print(f"До вызова функции: D = {D8}")

# Вызов функции
myfunction()

# Проверка значений переменных
print(f"После вызова функции: A = {A28}")
print(f"После вызова функции: C = {C28}")
print(f"После вызова функции: D = {D8}")
print(f"После вызова функции: B = {B28}")


# --------------------------------

# ------ Вложенные функции ------
# -- 6.11 Вложенная функция --


def mysum(*a):  # <- Функция с вложенной функцией
    txt0 = ["Чисел", "Квадратов", "Кубов"]  # <- Список

    def calc(n):  # <- Вложенная функция
        s = 0
        for m in range(len(a)):
            s += a[m] ** n
        return s

    # Вызов вложенной функции
    for k in range(len(txt0)):
        print(f"Сумма {txt0[k]}: {calc(k + 1)}")


# Вызов функции
mysum(1, 3, 5, 7)
# --------------------------------

# ------ Лямбда-функции ------
# -- 6.12 Использование лямбда-функции --
num12 = 10
L3 = lambda n: 2 * n + 1  # <- Функция на основе лямда-вырадения
# Проверка результата
print("Нечётные числа: ")
for k in range(num):
    print(L3(k), end=" ")

# Новое значение
L4 = lambda n: 2 ** n
# Проверка результата
print("\nСтепени двойки: ")
for k in range(num):
    print(L4(k), end=" ")

# Прямой вызов лямда-функции
print("\nКвадратные числа: ")
for k in range(num):
    print((lambda x: x * x)(k + 1), end=" ")


def calc1(x, y):  # <- Обычная функция
    return x + y


F = lambda x, y: calc1(x, y)  # <- Использование функции в лямбда-выражении
f = calc1  # <- Переменной присваивается имя функции
calc1 = lambda x, y: x * y  # <- Имени функции присваивается лямбда-выражение

# Проверка результата
print(f"\nВызов F(3, 5): {F(3, 5)}")
print(f"Вызов f(3, 5): {f(3, 5)}")
print(f"Вызов calc1(3, 5): {calc1(3, 5)}")


# --------------------------------

# ------ Функция как аргумент и результат ------
# -- 6.13 Функция как аргумент и результат --


def display(f, a, b):  # <- Аргумент функции - функция (и два числа)
    for k in range(a, b + 1):
        print("{0:4}".format(f(k)), end=" ")
    print()


def mypow(n):  # <- Результат функции - функция
    return lambda x: x ** n


def apply(f, h):  # <- Аргумент функции - функции. Результат - функция
    def calc(x):
        return f(h(x))

    return calc


# Определение функция
A29 = mypow(2)
B29 = mypow(3)
C29 = apply(lambda x: 2 * x + 1, lambda x: 2 * x)

# Проверка результата
print("x   ", end="")
display(lambda x: x, 1, 5)
print("A(x)", end="")
display(A29, 1, 5)
print("B(x)", end="")
display(B29, 1, 5)
print("C(x)", end="")
display(C29, 1, 5)

# Определение функции
F1 = lambda f: lambda x: f(f(x))
# Проверка результата
print(f"F(x->x*x) (5): {F(lambda x: x * x)(5)}")
print(f"F(x->2*x+1) (5): {F(lambda x: 2 * x + 1)(5)}")


# --------------------------------

# ------ Рекурсия ------
# -- 6.14 Использование рекурсии --
# Функции с рекурсивным вызовом


def mysum1(n):  # <- Функция для вычисления суммы чисел
    if n == 0:
        return 0
    else:
        return n + mysum1(n - 1)


def fib(n):  # <-Функция для вычисления чисел фибоначчи
    if n == 1 or n == 2:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)


def show3(txt):  # <- Функция для инверсного отображения текста/списка
    if len(txt) == 0:
        print("|")
    else:
        print(f"|{txt[-1]}", end="", sep="")
        show(txt[:-1])


# Вызов функций
print("Сумма чисел: ")
for k in range(12):
    print(mysum1(k), end=" ")
print("\nЧисла фибоначчи: ")
for k in range(15):
    print(fib(k + 1), end=" ")
print("\nИнверсия текста")
show3("Hello Python")
print("Инверсия списка")
show3([1, 2, 3, 4, 5])


# --------------------------------

# ------ Декораторы функций ------
# -- 6.15 Декораторы функций --
# Функции для использования в декораторах


def A(h):
    return lambda x: h(x) * h(7 - x)


def B(h):
    return lambda x, y: h(x, y) + h(y, x)


def C(h):
    return lambda x: h(x, 10 - x)


# Функции с декораторами
@A
def f(x):
    return 2 * x - 1


@B
def F(x, y):
    return (8 - x) * (y + 1)


@C
def H(x, y):
    return x * y


# Проверка результата
print(f"f(3) = {f(3)}")
print(f"F(5, 7) = {F(5, 7)}")
print(f"H(6) = {H(6)}")


# --------------------------------

# ------ Функции-генераторы ------
# -- 6.16 Функции-генераторы --
# Функции-генераторы


def names():
    yield "Дядя Федор"
    yield "Пес Шарик"
    yield "Кот Матроскин"


def colors():
    L = ["Красный", "Желтый", "Зеленый", "Синий"]
    for clr in L:
        yield clr


def myrange(n):
    for k in range(n):
        yield 2 * k + 1


# Использование функции-генераторов
print("Они из Простоквашино: ")
for name in names():
    print(name)
print(list(names()))
R = colors()
print("Цветовой спектр: ")
for r in R:
    print(r, end=" ")
print("\nЕщё одна попытка...")
for r in R:
    print(r, end=" ")
print("Ничего нет? Это нормально")
print("Нечетные числа: ")
print(list(myrange(10)))
print(tuple(myrange(10)))
N1 = myrange(8)
A30 = list(N1)
print(f"A = {A30}")
B30 = list(N1)
print(f"B = {B30}")
for num in myrange(8):
    print(num, end=" ")
print()


# --------------------------------

# ------ Аннотации и документирование в функциях ------
# -- 6.17 Использование документирования --
# Функции с документированием


def show4(txt):
    """Это функция show() с одним аргументом."""
    print(f"Единственный аргумент: {txt}")


def display1(a, b):
    """ Это функция display() с двумя аргументами. """
    print(f"[1] Первый аргумент: {a}")
    print(f"[2] Первый аргумент: {b}")


def hello():  # <- Функция без документирования
    print("Всем привет!")


# Вызов функция и проверка документирования
print(show.__doc__)
show4('A')
print(display1.__doc__)
display1('B', 'C')

f = show  # <- Переменная ссылается на функцию
# Вызов функций и проверка документирования
print(f.__doc__)
f('D')
display1.__doc__ = "Новый текст для display()"  # <- Новый текст документирования для функции
# Проверка результата
print(display1.__doc__)
display1('E', 'F')
hello.__doc__ = "Функция hello()"  # <-Создается документирование для функции
# Проверка результата
print(hello.__doc__)
hello()


# --------------------------------

# -- 6.18 Использование аннотаций --


def show5(txt: "Текст" = "Функция show()") -> "Результата нет":  # <- Функция с аннотациями
    print(txt)


show5()  # <- Вызов функции
print(show5.__annotations__)  # <- Словарь аннотаций
# Аннотации
for k in show.__annotations__:
    print(f"{k} - {show5.__annotations__[k]}")

# --------------------------------

# ---------------------------------- Глава 7 ----------------------------------
# ------------------------------ Файлы и данные -------------------------------
# ------ Числовые данные ------

# -- 7.1 Целые числа в разных системах счисления --
print("Числа заданы в разных системах: ")
A31 = 0b10011  # <- Число 19 в двоичной системе
print(f"А = {A31}")
B31 = 0o135  # <- Число 93 в восьмеричной системе
print(f"B = {B31}")
C31 = 0xA2B  # <- Число в 2603 в шестнадцатеричной системе
print(f"С = {C31}")
print(f"C-A-B = {C31 - A31 - B31}")

# Обратное преобразование
print("Обратное преобразование: ")
A31 = int("10011", 2)
print(f"{bin(A31)} = {A31}")
B31 = int("0o135", 8)
print(f"{bin(B31)} = {B31}")
C31 = int("0xA2B", 16)
print(f"{bin(C31)} = {C31}")
D7 = int("ABC", 20)
print(f"{bin(D7)} = {D7}")

# --------------------------------

# -- 7.2 Побитовые операции --
A32 = 13
print(f"А = {A32}")
B32 = 7
print(f"B = {B32}")

# Побитовые операции
print(f"A&B = {A32 & B32}")
print(f"A|B = {A32 | B32}")
print(f"A^B = {A32 ^ B32}")
print(f"~A+B = {~A32 + B32}")

# Побитовые сдвиги
print(f"B >> 1 = {B32 >> 1}")
print(f"B << 2 = {B32 << 2}")

# --------------------------------

# -- 7.3 Действительные числа --
print("Дробные значения: ")
A33 = Fraction(2, 5)
print(f"A = {A33}")
B33 = Fraction(3, 7)
print(f"B = {B33}")
C33 = A33 + B33
print(f"A + B = {C33}")
print("Действительные числа: ")
X1 = 2 / 5
print(f"X = {X1}")
D8 = X1 + B33
print(f"X + B = {D8}")
print("Числа заданной точности: ")
A33 = Decimal('1.01')
print(f"A = {A33}")
B33 = Decimal('2.02')
print(f"B = {B33}")
C33 = A33 + B33
print(f"A + B = {C33}")
print(f"1.01 + 2.02 = {1.01 + 2.02}")

# --------------------------------

# -- 7.4 Комплексные числа --
# Комплексные числа
A34 = 3 + 4j
print(f"A = {A34}")
print(f"Re(A) = {A34.real}")
print(f"Im(A) = {A34.imag}")
print(f"|A| = {abs(A34)}")
B34 = -1 + 1j
print(f"B = {B34}")
C34 = complex(0, 1)
print(f"C = {C34}")

# Арифметические операции
print(f"A+B = {A34 + B34}")
print(f"A*C = {A34 + C34}")
print(f"A/B = {A34 / B34}")

# --------------------------------

# ------ Логические значения ------
# -- 7.5 Логические операторы --
A35 = 123
print(f"A = {A35}")
B35 = "Python"
print(f"B = {B35}")
C35 = []
print(f"C = {C35}")
D9 = 0
print(f"F = {D9}")

print(f"A or B: {A35 or B35}")
print(f"A and B: {A35 and B35}")
print(f"C or D: {C35 or D9}")
print(f"C and D: {C35 and D9}")
# --------------------------------

# ------ Дата и время ------
# -- 7.6 Объект для реализацтт момента времени --
mytime = time(13, 35, 20)  # Объект для реализации момента времени
print(f"Время: {mytime}")  # <-Проверка результата

# Использование полей объекта
print(f"Часа: {mytime.hour}")
print(f"Минуты: {mytime.minute}")
print(f"Секунды: {mytime.second}")

newtime = mytime.replace(15, second=45)  # <- Создание нового объекта на основе существующего
print(f"Время: {newtime}")  # <-Проверка результата
mytime = time.fromisoformat("12:34:56")  # <- Создание нового объекта
print(f"Время: {mytime}")  # <-Проверка результата

# --------------------------------

# -- 7.7 Объект для реализации даты --
myday = date(2019, 10, 22)  # <- Объект для реализации даты
print(f"Первая дата: {myday}")  # <- Проверка результата

# Использование полей объекта
print(f"Год: {myday.year}")
print(f"Месяц: {myday.month}")
print(f"Число: {myday.day}")

# Определение дня недели
print(f"День недели: {myday.weekday()}")
print(f"День недели: {myday.isoweekday()}")

newday = myday.replace(1985, day=15)  # <- Создание нового объекта на основе существующего
print(f"Вторая дата: {newday}")  # <- Проверка результата

newday = date.fromisoformat("1998-08-12")  # <- Создание новго объекта
print(f"Новая дата: {newday}")  # <- Проверка результата

thisday = date.today()  # <- Объект для текущей даты
print(f"Сегодня: {thisday}")  # <- Проверка результата

delta2 = myday - thisday  # <- Разность дат
print(f"До первой даты: {delta2}")  # <- Проверка результата

# --------------------------------

# -- 7.8 Объект для реализации даты и времени --
md = datetime(2019, 10, 22, 13, 27, 45)  # <- Объект для реализации даты и времени
print(f"Дата и время: {md}")  # <- Проверка результата

# Использование полей объекта
print(f"Год: {md.year}")
print(f"Месяц: {md.month}")
print(f"Число: {md.day}")
print(f"Часы: {md.hour}")
print(f"Минуты: {md.minute}")
print(f"Секунды: {md.second}")

# Определение дня недели
print(f"День недели: {md.weekday()}")
print(f"День недели: {md.isoweekday()}")

d = md.date()  # <- Дата
print(f"Дата: {d}")  # <- Проверка результата
t = md.time()  # <- Время
print(f"Время: {t}")  # <- Проверка результата

nd = md.replace(1985, day=3, second=15)  # <- Создание нового объекта на основе существующего
print(f"Дата и время: {nd}")  # <- Проверка результата
nd = datetime.fromisoformat("1998-08-12 11:25:36")  # <- Создание новго объекта
print(f"Новая дата и время: {nd}")  # <- Проверка результата
td = datetime.today()  # <- Объект для текущей даты и времени
print(f"Сегодня и сейчас: {td}")  # <- Проверка результата
delta3 = md - td  # <- Разность дат

# Проверка результата
print(f"Интервал времени: {delta3}")
print(f"Дни: {delta3.days}")
print(f"Секунды: {delta3.seconds}")
print(f"Интервал в секундах: {delta3.total_seconds()}")

# --------------------------------

# ------ Работа с файлами ------
# -- 7.9 Считывание содержимого текстового файла --
mf = open("poertry.txt")  # <- Открываем текстовый файл для чтения
txt = mf.read()  # <- Считывается содержимого файла
print("Содержимое файла: ")
print(txt)  # <- Отображение содержимого файла
mf.close()  # <- Закрываем файл
print("Файл закрыт...")

# --------------------------------

# -- 7.10 Построчное считывание содержимого файла --
mf1 = open("poertry.txt")  # <- Открыаем текстовый фалй для чтения
k = 1  # <- Переменная для нумерации срок

# Построчное считывание файла
print("Построчное считывание файла")
for L in mf:
    print(f"[{str(k)}] {L}", end="")  # <- Отображение номера строки и самой строки
    k += 1  # <- Новое значение для номера строки
mf1.close()  # <- Закрываем файл
print("\nФайл закрыт...")

# --------------------------------

# -- 7.11 Ещё один способ построчного считывания --
mf2 = open("poertry.txt")  # <- Открыаем текстовый фалй для чтения
k = 1  # <- Переменная для нумерации строк

# Построчное считывание файла
print("Построчное считывание файла")
L1 = mf2.readline()
while L1 != "":
    print(f"[{str(k)}] {L}", end="")  # <- Отображение номера строки и самой строки
    for s in L1:  # <- Замена пробела на подчеркивание
        if s == ' ':
            s = '_'
        print(s, end="")
    k += 1  # <- Новое значение для номера строки
    L1 = mf2.readline()  # <- Считывание новой строки

mf1.close()  # <- Закрываем файл
print("\nФайл закрыт...")

# --------------------------------

# -- 7.12 Запись данных в файл --
txt = input("Введите текст: ")  # <- Считывается текст
mf3 = open("poertry.txt", 'w')  # Файл открывается дла записи
mf3.write(txt)  # <- Текст записывается в файл
mf3.close()  # <- Закрывается файл
print("Текст записан в файл")  # <- Сообщение о завершении копирования

# --------------------------------

# -- 7.13 Чтение и запись данных --
name = "poertry2.txt"  # <- Имя файла
txt = "Python"  # <- Текст для записи в файл
print(f"Текст для записи в файл: {txt}")
mf4 = open(name, 'w+t')  # <-Файл открывается длячтения и записи
mf4.write(txt)  # <- Текст записывается в файл
mf4.seek(0)  # <- Переходим в начало файла
print(f"{mf4.tell} -> {mf.read(1)}")  # <- Первый символ в файле
mf4.seek(0, 2)  # <- Переходим в конец файла
num13 = mf4.tell() - 1  # <- Позиция с последним символов в файле
mf4.seek(num13)  # <- Переходим на позицию с последним символом
print(f"{mf.tell()} -> {mf.read(1)}")  # <- Последний символ в файле
mf4.seek(0)  # <- Возвращаемся в начало файла
print(f"Три символа: {mf4.read(3)}")  # <- Три последних символа
mf4.close()  # <- Закрывается файла
print("Программа завершила выполнение")

# --------------------------------

# -- 7.14 Копирование файла --
print("Начинается копирование файла")
try:  # <- Контролируемый код
    A36 = open("poertry.txt", "rb")  # <- Бинарный файл открывается для чтения
    B36 = open("poertry3.txt", "xb")  # <- Создается бинарный файл
    # Содержимое первого файла считывается и записывается во второй файл
    B36.write(A36.read())

    # Файлы закрываются
    A36.close()
    B36.close()
    print("Копирование прошло успешно")
except FileExistsError:  # <- Если второй файл уже существует
    print("Ошибка: такой файл уже существует")
except:  # <- Все прочие ошибки
    print("Ошибка доступа к файлу")
print("Программа завершила выполнение")

# --------------------------------

# ---------------------------------- Глава 8 ----------------------------------
# ------------------------------ Классы и объекты -------------------------------
# ------ Описание классов и создание объектов ------

""" Обзая конструкция с описанием класса
    class Имя:
        Описание класса
"""


# -- 8.1 Знакомство с классами и объектами --
# Описание класса


class MyClass:
    pass


# Создание объектов на основе класса
a1 = MyClass()
b1 = MyClass()

# Объекты
print(f"Объект A: {a1}")
print(f"Объект B: {b1}")

# Тип объектов
print(f"Класс объекта A: {type(a1).__name__}")
print(f"Класс объекта B: {type(b1).__name__}")

print(f"A == B: {a1 == b1}")  # <- Сравнение объектов


# --------------------------------

# -- 8.2 Знакомство с полями и методами --
# Описание класса


class MyClass:
    def set(self, n):  # <- Методы для присваивания значения полю
        self.number = n

    def show(self):  # <- Метод для отображения значения поля
        print(f"Поле number = {self.number}")


# Создание объектов
A = MyClass()
B = MyClass()

# Присваивание значений полям объектов
A.set(100)
B.set(200)

# Проверка значений полей объектов
A.show()
B.show()

# Присваивание значений полям объектов
A.number = 123
B.number = 321

# Проверка значений полей объектов
A.show()
B.show()


# --------------------------------

# -- 8.3 Явное создание поля объекта --
# Описание класса


class MyClass:
    def set(self, n):  # <- етоды для присваивания значения полю
        self.number = n

    def show(self):  # <- Метод для отображения значения поля
        print(f"Поле number = {self.number}")


obj = MyClass()  # <- Создание объекта
print(f"Наличие поля number: {hasattr(obj, "number")}")  # <- Проверка наличия поля
try:
    obj.show()  # <- Проверка значения поля
except AttributeError:
    print("Поля number у объекта нет!")

obj.number = 123
print(f"Наличие поля number: {hasattr(obj, "number")}")  # <- Проверка наличия поля
obj.show()  # <- Проверка значения поля
obj.set(321)  # <- Новое значение поля
obj.show()  # <- Проверка значения поля


# --------------------------------

# ------ Конструкторы и деструкторы ------
# -- 8.4 Знакомство с конструктором и декструктором --
# Описание класса


class MyClass:
    def __init__(self, str_name="Белый"):  # <- Конструктор
        self.name = str_name
        print(f"Создан объект: {self.name}")

    def __del__(self):  # <- Деструктор
        print(f"Удален объект: {self.name}")


def create(str_name):  # <- Функция
    obj_str = MyClass(str_name)


# Создание объектов
A = MyClass()
B = MyClass("Красный")
C = MyClass("Синий")

create("Жёлтый")  # <- Вызов функции
C.name = "Зелёный"  # <- Полю присваивается новое значение

# Удаление объектов
del A
del B
del C


# --------------------------------

# ------ Объект реализации класса ------
# -- 8.5 Объект реализации класса--
# Первый класс


class Alpha:
    pass


# Второй класс


class Bravo:
    pass


MyClass1 = Alpha  # <- Переменной присваивается имя класса
A = MyClass()  # <- Создание объекта
MyClass1 = Bravo  # <- Переменной присваивается имя класса
B = MyClass()  # <- Создание объекта
Alpha = Bravo  # <- Присваивание классов
C = Alpha()  # <- Создание объекта
MyClass1 = A.__class__  # <- Получение ссылки на объект реализации класса
D = MyClass()  # <- Создание объекта

# Проверка типа объектов
print(f"Объект А: {type(A).__name__}")
print(f"Объект B: {type(B).__name__}")
print(f"Объект C: {type(C).__name__}")
print(f"Объект D: {type(D).__name__}")

# Изменение названия классов
MyClass1.__name__ = "First"
Bravo.__name__ = "Second"

# Проверка типа объектов
print(f"Объект А: {type(A).__name__}")
print(f"Объект B: {type(B).__name__}")
print(f"Объект C: {type(C).__name__}")
print(f"Объект D: {type(D).__name__}")


# --------------------------------

# -- 8.6 Поля и методы класса --
# Описание класса


class MyClass:
    color = "Красный"  # <- Поле класса

    # Методы класса
    def set(self, txt):
        MyClass.color = txt

    def show(self):
        print(MyClass.color)


# Вызов методов класса
MyClass.show()
MyClass.set("Зеленый")
print(MyClass.color)  # <- Отображение значения поля класса
MyClass.color = "Синий"  # <- Новое значение для поля класса
MyClass.show()  # <- Вызов метода класса

# Создание объектов класса
A = MyClass()
B = MyClass()

# Проверка значения поля
print(f"Класс: {MyClass.color}")
print(f"Объект А: {A.color}")
print(f"Объект В: {B.color}")
A.color = "Белый"  # <- Присваивание значения поля

# Проверка значения поля
print(f"Класс: {MyClass.color}")
print(f"Объект А: {A.color}")
print(f"Объект В: {B.color}")
MyClass.color = "Желтый"

# Проверка значения поля
print(f"Класс: {MyClass.color}")
print(f"Объект А: {A.color}")
print(f"Объект В: {B.color}")
del A.color  # <- Удаление поля из объекта А

# Проверка значения поля
print(f"Класс: {MyClass.color}")
print(f"Объект А: {A.color}")
print(f"Объект В: {B.color}")


# --------------------------------

# -- 8.7 Методы класса и объекта --
# Описание класса


class MyClass:
    def __init__(self):  # <- Конструктор
        self.value = 123
        print(f"Создается объект: {self.value}")

    def __del__(self):  # <- Деструктор
        print(f"Удаляется объект: {self.value}")

    def set(self, n):  # <- Метод для присваивания значения полю
        self.value = n

    def show(self):  # <- Метод для отображения значения поля
        print(f"Поле объекта: {self.value}")


obj = MyClass()  # <- Создание объекта

# Вызов методов из объекта
obj.show()
obj.set(100)

# Вызов методов из объекта
MyClass.show(obj)
MyClass.set(obj, 200)

obj.show()  # <- Проверка значения поля
MyClass.__init__(obj)  # <- Явный вызов конструктора
MyClass.__del__(obj)  # <- Явный вызов деструктора
obj.show()  # <- Проверка значения поля
obj.value = 123  # <- Изменение значения поля
obj.show()
MyClass.__init__(obj)  # <- Явный вызов конструктора
MyClass.__del__(obj)  # <- Явный вызов деструктора
obj.show()  # <- Проверка значения поля


# --------------------------------

# ------ Операции с атрибумтами классов и объектов ------
# -- 8.8 Атрибуты классов и объектов --


class Alpha:  # <- Первый класс
    pass


class Bravo:  # <- Второй класс
    name = "Bravo"

    def display(self):
        print(f"Поле name: {Bravo.name}")

    def show(self):
        print(f"Поле value: {self.value}")

    def __init__(self):
        self.value = 123


# Создание объектов
A = Alpha()
B = Bravo()

# Атрибуты первого класса
print("Класс Alpha")
n = 1
for s in Alpha.__dict__:
    print(f"[{str(n)}] {s}: {Alpha.__dict__[s]}")
    n += 1

# Атрибуты второго класса
print("Класс Bravo")
n = 1
for s in Bravo.__dict__:
    print(f"[{str(n)}] {s}: {Bravo.__dict__[s]}")
    n += 1

# Атрибуты объектов
print(f"Объект А: {A.__dict__}")
print(f"Объект B: {B.__dict__}")
Bravo.display()  # <- Вызов метода класса
Alpha.display = Bravo.display  # <- Создание атрибута класса
del Bravo.display  # <- Удаление атрибута класса
B.show()  # <- Вызов метода из объекта
A.color = "Красный"  # <- Красный
B.show = lambda: print(f"Объект B: {B.value}")  # <- Создание атрибута класса

# Атрибуты первого класса
print("Класс Alpha")
n = 1
for s in Alpha.__dict__:
    print(f"[{str(n)}] {s}: {Alpha.__dict__[s]}")
    n += 1

# Атрибуты второго класса
print("Класс Bravo")
n = 1
for s in Bravo.__dict__:
    print(f"[{str(n)}] {s}: {Bravo.__dict__[s]}")
    n += 1

# Атрибуты объектов
print(f"Объект А: {A.__dict__}")
print(f"Объект B: {B.__dict__}")

# Вызов методов
Alpha.display()
Bravo.show(B)
B.show()


# --------------------------------

# ------ Копирование объектов ------
# -- 8.9 Копирование объектов --


class MyClass:
    pass


A = MyClass()  # <- Создание объекта
# Поля объекта
A.value = 100
A.nums = [1, 2, 3]
B = A  # <- Присваиваем ссылки на объекты
C = copy(A)  # Копия объекта
D = deepcopy(A)  # <- Полная копия объекта
print("Созданы объекты")

# Поля объектов
print(f"A: {A.value} и {A.nums}")
print(f"B: {B.value} и {B.nums}")
print(f"C: {C.value} и {C.nums}")
print(f"D: {D.value} и {D.nums}")
print("A.value = 200 и A.nums[1] = 0")

# Новое значение для полей
A.value = 200
A.nums[1] = 0

# Поля объектов
print(f"A: {A.value} и {A.nums}")
print(f"B: {B.value} и {B.nums}")
print(f"C: {C.value} и {C.nums}")
print(f"D: {D.value} и {D.nums}")
print("Удаление переменой")
del A
print("B.value = 300 и B.nums[2] = 4")

# Новое значение для полей
B.value = 300
B.nums[2] = 4

# Поля объектов
print(f"B: {B.value} и {B.nums}")
print(f"C: {C.value} и {C.nums}")
print(f"D: {D.value} и {D.nums}")


# --------------------------------

# ------ Документирование и декораторы ------
# -- 8.10 Документированеи в классах --


class Alpha:  # <- Первый класс
    """ Это класс Alpha """
    pass


class Bravo:  # <- Второй класс
    """ Это класс Bravo """
    pass


# Информация о классах
print(Alpha.__doc__)
print(Bravo.__doc__)

# Объекты классов
A = Alpha()
B = Bravo()

# Изменение строки документирования
Alpha.__doc__ = "Первый класс"
B.__class__.__doc__ = "Второй класс"

# Информация о классах
print(A.__class__.__doc__)
print(B.__doc__)


# --------------------------------

# -- 8.11 Класс как аргумент и результат функции --
# Функция получает ссылку на класс в качестве агумента и результатом возвращает ссылку на класс


def F(Alpha_a):
    class Bravo:  # <- Внутренний класс
        value = Alpha_a()

    Bravo.__name__ = "My" + Alpha.__name__
    return Bravo


class Charlie:  # <- Описание класса
    def __init__(self):  # <- Конструктор
        self.number = 123

    def show_met(self):  # <- Метод для отображения значения поля
        print(f"Поле Number: {self.number}")


# Создание объекта на основе класса, полученного при вызове функции
obj = F(Charlie)()

# Проверка результата
obj.value.show_met()
print(f"Класс объекта obj: {obj.__class__.__name__}")
print(f"Класс поля value: {obj.value.__class__.__name__}")


# --------------------------------

# -- 8.12 Декоратор класса --


def func(Alpha_value):  # <- Функция для декоратора
    class Bravo:
        value = Alpha_value()

    Bravo.__name__ = "My" + Alpha.__name__
    return Bravo


# Класс с декоратором
@func
class Charlie:
    def __init__(self):
        self.number = 123

    def show(self):
        print(f"Поле number: {self.number}")


obj = Charlie()  # <- Создание объекта
obj.value.show()  # <- Проверка результата
print(f"Класс объекта obj: {obj.__class__.__name__}")
print(f"Класс поля value: {obj.value.__class__.__name__}")


# --------------------------------

# ------ Использование классов и объектов ------
# -- 8.13 Объекты с разными полями --
# Описание класса


class MyClass:
    # Конструктор
    def __init__(self, val):
        if type(val) == int:  # <- # Если аргумент целочисленный
            self.number = val
        elif type(val) == str:  # <- # Если аргумент текстовый
            self.name = val
        elif type(val) == float:  # <- Если аргумент дествительно число
            self.value = val
        else:  # <_- Прочие случаи
            self.data = val

    def show(self):  # <- Метод для отображения значения поля
        list_value = ['number', 'name', 'value', 'data']  # <- Список с названиями полей
        for s in list_value:  # <- Перебор назваий полей
            if s in dir(self):  # <- Если поле существует
                print(f"{s} = {self.__dict__[s]}")  # <- Отображение названия и значения поля
                break  # <- Завершение оператора цикла
            else:  # <- Если поле не найлено
                print("Странный объект")


# Создание объектов и проверка полей
A = MyClass(123)
A.show()
del A.number
A.show()
B = MyClass("Объект В")
B.show()
C = MyClass(2.5)
C.show()
D = MyClass([1, 2, 3])
D.show()


# --------------------------------

# -- 8.14 Функции для создания объектов --


def craete4(fields, vals, name=None):  # Функция для создания объектов
    if type(name) != str:  # <- Если последний аргумент не текстовый  
        name = "MisterX"

    if type(fields) != list or type(vals) != list:  # <- Если первые два аргумента - не списки
        class MyClass:  # <- Внутренний класс
            def show(self):  # <- Метод
                print("Объект без полей")
                print(f"Класс {self.__class__.__name__}")
    else:  # <- Если первые два аргумента - списки
        class MyClass:  # <- Внутренний класс
            def __init__(self):  # <- Конструктор
                k = 0
                for f in fields:
                    self.__dict__[f] = vals[k]
                    k += 1

            def show(self):  # <- Метод
                print("Объект с полями: ")
                for s in dir(self):
                    if not s.startswith("_") and s != "show":
                        print(f"{s} = {self.__dict__[s]}")
                print(f"Класс {self.__class__.__name__}")

    MyClass.__name__ = name  # <- Название класса
    return MyClass()  # <- Результат функции


# Создание объекта и проверка полей
A4 = craete4(["red", "green", "blue"], [1, 2, 3], "MyColors")
A.show()

# Создание объекта и проверка полей
B = craete4(["alpha", "bravo"], ["Alpha", "Bravo"])
B.show()

# Создание объекта и проверка полей
C = craete4(1, 2, 3)
C.show()

# Изменение значений полей объекта
A.red = 100
A.green = 100
A.blue = 100
A.show()

# Создание объекта и проверка полей
D = A.__class__()
D.show()


# --------------------------------

# -- 8.15 Цепочка объектов --


class MyClass:  # <- Класс
    def __init__(self, name, n=1):  # <- Конструктор
        self.code = None
        self.name = name
        if n == 1:
            self.next = None
        else:
            self.next = MyClass(self.name, n - 1)
        self.set()

    def __del__(self):  # <- Деструктор
        print(f"Удаление: ", self.code)

    def set(self, num=1):  # <- Метод для заполнения цепочки кодами
        self.code = self.name + "[" + str(num) + "]"
        if self.next is not None:
            self.next.set(num + 1)

    def show(self):
        print(self.code)
        if self.next is not None:
            self.next.show()


# Создание цепочки объектов
print("Один объект: ")
A = MyClass("Alpha")
A.show()
print("Цепочка объектов: ")

B = MyClass("Bravo", 5)
B.show()
print("Начиная с третьего объекта: ")
B.next.next.show()

# Удаление объектов
print("Удаление объектов")
del A
del B

# --------------------------------

# ---------------------------------- Глава 9 ----------------------------------
# --------------------- Наследование и специальные методы ---------------------
# ------ Знакомство с наcледованием ------
# -- 9.1 Знакомство с наследованием --

# --------------------------------

# ---------------------------------- Глава 10 ----------------------------------
# --------------------- Обработка исключений и потоки ---------------------
# ------ Обработка исключений разных типов ------
# -- 10.1 Обработка исключений разных классов --

A = [10, 20, 30, 40]  # Список
for k in [0, 1, 2, 'три', 4, 3]:  # <- Оператор цикла
    try:  # <- Контролируемый код
        print(f"A[{str(k)}] = ", end="")
        A[k] /= (k - 1)
        print(A[k])
    # Обработка исключений
    except IndexError:
        print("Нет такого элемента")
    except ZeroDivisionError:
        A[k] = 0.0
        print(f"{A[k]} - деление на ноль")
    except TypeError:
        print("Неверный тип индекса")

# --------------------------------

# ------ Использование объекта исключения ------
# -- 10.2 Использование объекта исключения --

A = [10, 20, 30, 40]  # Список
for k in [0, 1, 2, 'три', 4, 3]:  # <- Оператор цикла
    try:  # <- Контролируемый код
        print(f"* Значение элемента A[{str(k)}]: ", end="")
        A[k] /= (k - 1)
        print(A[k])
    # Обработка исключений
    except (TypeError, IndexError) as error:
        print()
        print(f"Исключение класса {error.__class__.__name__}")
        print(error.__doc__)
        print(f"Базовый класс: {error.__class__.__bases__[0].__name__}")
    except ZeroDivisionError as error:
        print()
        print("Произошла ошибка деления на ноль")
        print("Цепочка наследования: ")
        for s in error.__class__.__mro__:
            print(s.__name__)
        A[k] = 0.0
        print(f"Элементу присвоено значение {A[k]}")

# --------------------------------

# ------ Вложенные блоки для обработки исключений ------
# -- 10.3 Вложенные блоки для обработки исключений --

A = [10, 20, 30, 40]  # Список
for k in [0, 1, 2, 'три', 4, 3]:  # <- Оператор цикла
    try:  # <- Внешний блок
        print(f"* Значение элемента A[{str(k)}]: ", end="")
        try:  # <- Внутренний блок
            A[k] /= (k - 1)
            print(A[k])
        except ZeroDivisionError:  # <- Внутренний блок обработки
            print("Попытка деления на ноль")
            A[k] = 0.0
            print(f"Новое значение {A[k]}")
        else:  # <- Блок выполняется, если нет ошибки
            print("Ошибки деления на ноль нет")
        finally:  # <- Блок выполняется всегда
            print("# Завершение внутреннего блока")
    # Внешний блок обработки
    except:
        print("Что-то полшло не так")
print("Программа заверишла выполненеие")

# --------------------------------

# ------ Искусственное генерирование исключений ------
# -- 10.4 Искусственное генерирование исключений --

print("Начинаем генерировать ошибки*")
error = Exception("Первая ошибка")  # <- Создание объекта исключения
try:  # <- Первый блок контролируемого кода
    try:  # <- Второк блок контролируемого кода
        try:  # <- Третий блок контролируемого кода
            raise error  # <- Генерирование исключения
        except:  # <- Обработка исключения для третьего блока
            print(error)
            raise  # <- Повторное генерирование исключения
    except Exception as e:  # <- Обработка исключения для второго блока
        print("Повторная обработка")
        print(e)
    try: # <- Внутренний блок контролируемого кода
        raise ArithmeticError("Вторая ошибка")
    except ArithmeticError as e:  # <- Обработка исключения для внутреннего блока
        print(e)
    raise Warning  # <- Генерирование исключения
except Warning:  # <- Обработка исключения для первого блока
    print("Ещё одна ошибка")
print("Ошибок больше нет")

# --------------------------------

# ------ Создание классов ислючений ------
# -- 10.5 Создание классов ислючений --


class MyError(Exception):  # <- Класс исключения

    def __init__(self, code=0, msg="Исключение Error"):  # <- Конструткор
        self.code = code
        self.message = msg

    def __str__(self):  # <- Метод для приведения к текстовому формату
        txt_value = self.message + "\nКод ошибки: " + str(self.code)
        return txt


try:  # <- Внешний блок конролируемого кода
    print("Создаем собственную ошибку")
    try:  # <- Внутренний блок контролипуемого кода
        raise MyError(123)  # <- Генерирование исключения
    except MyError as error:  # <- Внутренний блок обработки исключения
        print(error)
        # Изменение параметров объекта
        error.code = 321
        error.message = "Та же ошибка MyError"
        # Повторное генерирование исключения
        raise
except Exception as error:  # <- Внешний блок обработки исключения
    print(error)

# --------------------------------

# ------ Использование исключений ------
# -- 10.6 Сумма натуральных чисел --

while True:  # <- Оператор цикла с истинным условием
    res = input("Введите натуральное число: ")  # <- Считывание значения
    try:  # <- Контролируемый код
        num = int(res)  # <- Попытка преобразования в целое число
        if num < 1:  # <- Если число меньше единицы
            raise ArithmeticError(msg := "Число должно быть натуральным")  # <- Генерирование исключения
    # Обработка исключений
    except ArithmeticError as error:
        print(error)
    except:
        print("Ошибка ввода")
    else:  # <- Если ошибок не было
        break  # <- Завершение оператора цикла
print(f"Сумма от 1 до {num} = {sum(range(num+1))}")  # <-Вычисление суммы натуральных чисел

# --------------------------------

# -- 10.7 Решение линейного уравнения --


def solve(A_value, B_value):  # <- Функция для решения линейного уравнения
    try:  # <- Контролируемый код
        # Преобразование к числовому формату
        a_float = float(A_value)
        b_float = float(B_value)
    except:  # <- Обработка исключения
        raise ValueError("Неверный формат данных")  # <- Генерирование исключения
    # Проверка значений коэффициентов
    if a_float == 0:
        if b_float != 0:
            raise ArithmeticError("Решений нет")  # <- Генерирование исключения
        else:
            raise Warning("Решение - любое число")  # <- Генерирование исключения
    return b_float / a_float


# Использование функции для решения уравнений
print("* Решаем линейные уравнения")
# Списки с коэффициентов для уравнений
A = [2.5, 2, 'три', 10, 0, 0.0]
B = [3.0, 4, 0, 'пять', 5, 0]
# Вызов функции с разными аргументами
for k in range(len(A)):
    a = A[k]
    b = B[k]
    print(f"[{k + 1}] Уравнение: {a}*x = {b}", sep="")
    try:  # <- Контролируемый код
        print(f"x = {solve(a, b)}")
    # Обработка исключений
    except ValueError as error:
        print("Неприятная ситуация №1")
        print(error)
    except ArithmeticError as error:
        print("Неприятная ситуация №2")
        print(error)
    except Warning as error:
        print("Странная ситуация")
        print(error)
print("* Все управнения решены")

# --------------------------------

# -- 10.8 Генерирование списка --


class MyError(Exception):  # <- Класс исключения
    def __init__(self):  # <- Конструктор
        self.values = []

    def __add__(self, val):  # <- Метод обрабатывает операцию сложения
        self.values.append(val)
        return self


def get_my_error(value):  # <- Функция с рекурсивным вызовом генерирует исключение
    try:  # <- Контролируемый код
        if value <= 1:
            raise MyError  # <- Генерирование исключения
        get_my_error(value - 1)  # <- Рекурсивный вызов функции
    except MyError as error_:  # <- обработка исключения
        raise error_+value  # <- Генерирование исключения


def get_list(value):  # <- Функция для создания списка
    try:  # <- Контролируемый код
        get_my_error(value)  # <- Вызов функциию генерирующей исключение
    except MyError as error_:  # <- Обработка исключения
        return error_.values  # <- Результат функции


# Создание списков
A = get_list(10)
print(A)
B = get_list(7.5)
print(B)

# --------------------------------

# ------ Знакомство с потоками ------
# -- 10.9 Знакомство с потоками --


def alpha1():  # <- Функция для вызова в главном потоке
    for k in range(5):
        sleep(1.5)  # <- Пауза выполнения потока
        print(f"[{k + 1}] Alpha", sep="")


def bravo1():  # <- Функция для выполнения в дочернем потоке
    for k in range(5):
        print(f"[{k + 1}] Bravo", sep="")
        sleep(1)  # <- Пауза в выполнении потока


t = Thread(target=bravo1)  # <- Создание объекта дочернего потока
t.start()  # <- Запуск дочернего потока на выполнение
alpha1()  # <- Вызов функции в главном потоке

# --------------------------------

# -- 10.10 Вызов в потоке функции с рагументами --


def display1(count, time, text):  # <- Функция с тремя аргументами
    for k in range(count):
        sleep(time)  # <- Пауза в выполнении потока
        print(f"[{k + 1}] {text}", sep="")


print("Начинается выполнение программы")
t = Thread(target=display1, args=(5, 2, "Дочерний поток"))  # <- Создание объекта дочернего потока
t.start()  # <- Запуск дочернего потока на выполнение
display1(3, 1.5, "Главный поток")  # <- Вызовфункции в главном потоке
t.join()  # <- Ожидание завершения дочернего потока
print("Программа завершила выполнение")

# --------------------------------

# -- 10.11 Использование вызываемого объекта --


class MyClass:  # <- Класс для создания вызываемого объекта
    def __init__(self, text):  # <- Конструктор
        self.text = text

    def __call__(self, count, time):  # <- Метод вызывается при вызове объекта
        for k in range(count):
            sleep(time)
            print(f"[{k + 1}] {self.text}", sep="")


print("Начинается выполнение программы")
obj1 = MyClass("Дочерний поток")  # <- Создание вызываемого объекта
t = Thread(target=obj1, kwargs={"time": 2, "count": 5})  # <- Создание объекта дочернего потока
t.start()  # <- Запуск дочернего потока на выполнение
MyClass("Главный поток")(3, 1.5)  # <- Вызов анонимного объекта в главном потоке
if t.is_alive():
    t.join()
print("Программа завершила выполненеи")

# --------------------------------

# -- 10.12 Создание потоков и наследование --


class MyThread(Thread):  # <- Производный класс
    def __init__(self, count, time, text):  # <- Конструтор
        super().__init__()  # <- Вызов конструктора юазового класса
        # Присваивание значений полям
        self.count = count
        self.time = time
        self.text = text

    def run(self):  # <- Присваивание значений полям
        for k in range(self.count):
            sleep(self.time)
            print(f"[{k + 1}] {self.text}", sep="")


print("Начинается выполнение программы")

# Создание объектов для дочерних потоков
A = MyThread(5, 2, "Alpha")
B = MyThread(3, 1.5, "Bravo")

# Запуск дочерних потоков на выполнение
A.start()
B.start()

# Ожидание завершения дочерних потоков
if A.is_alive():
    A.join()
if B.is_alive():
    B.join()

print("Программа завершила выполнение")

# --------------------------------

# ------ Взаимодействие потоков ------
# -- 10.13 Блокировка ресурса --


def calc(txt, op):  # <- Функция для выполнения в потоке
    global number  # <- Глобальная переменная

    for k in range(3):  # <- Оператор цикла
        mylock.acqurie()
        print(f"{txt}: ресурс блокирован", sep="")

        try:  # <- Контролируемый код
            print(f"{txt} прочитано: {number}")  # <- Считывание значения переменной
            val = number  # <- Запоминается значение переменной
            sleep(1)  # <- Пауза в выполнении потока

            # Изменение значения переменной
            if op:
                number = val + 1
            else:
                number = val - 1

            print(f"{txt} записано: {number}")  # <- Отображение значения переменной
        finally:
            print(f"{txt} ресурс разблокирован", sep="")
            print("------------------------------")
            mylock.release()  # <- Разблокировка ресурса
        sleep(1)


number = 0  # <- Начальное значение глобальной переменной
mylock = Lock()  # <- Объект блокировки
# Объект блокировки
A = Thread(target=calc, args=['A', True])
B = Thread(target=calc, args=['A', False])

# Запуск дочерних потоков на выполнение
A.start()
B.start()

# Ожидание завершения потоков
A.join()
B.join()

# --------------------------------

# -- 10.14 Взаимодействие потоков --


def display2(txt):  # <- Функция для выполнения в потоке
    A = [1, 2]
    B = ['A', 'B']
    sleep(1)
    myevent.wait()  # <- Ожидание установки флага
    myevent.clear()  # <- Отмена установки флага
    for a in A:
        print(f"[{a}] {txt}", sep="")
    myevent.set()  # <- Установка флага
    sleep(1)
    myevent.wait()  # <- Ожидание установки флага
    myevent.clear()  # <- Отмена утсановки флага
    for b in B:
        print(f"[{b}] {txt}", sep="")
    myevent.set()  # <- Установка флага


myevent = Event()  # <- Создание объекта
myevent.set()  # <- Установка флага
# Обекты дочерних потоков
F = Thread(target=display2, args=["Первый"])
S = Thread(target=display2, args=["Второй"])
# Запуск дочерних потоков
F.start()
S.start()
# Ожидание завершения дочерних потоков
F.join()
S.join()

# --------------------------------

# ------ Примеры использования потоков ------
# -- 10.15 Вчисление суммы целых чисел --


def mysum3():  # <- Функция для вызова в потоке
    global num  # <- Глобальная переменная
    k = 1  # <- Добавка к сумме
    txt = str(num)  # <- Текст для отображения
    while myevent.is_set():  # <- Вычисление суммы
        num += k  # <- К сумме прибавляется слагаемое
        txt += f" + {str(k)}"  # <- Новое значение для текста
        print(f"[{k}] {txt} = {num}", sep="")  # <- Отображение текущего значения суммы
        k += 1  # <- Добавка для следующей итерации
        sleep(0.3)  # <- Пауза в выполнении потока


print("Сумма целых чисел")
t = Thread(target=mysum3)  # <- Создание объекта дочернего потока
num = 0  # <-Начальное значение для суммы
myevent = Event()  # Объект для синхранизации потоков
myevent.set()  # <- Установка флага
t.start()  # <- Запуск дочернего потока на выполнение
sleep(2)  # <- Пауза в выполнении главного потока
myevent.clear()  # <- Отмена флага
if t.is_alive():  # <- Ожидание завершения выполнения дочернего потока
    t.join()
print(f"Результат: {num}")  # <- Результат вычислений

# --------------------------------

# -- 10.16 Заполнение списка --


def from_left():  # <- Функции для выполнения в дочерних потоках
    global first, last, L
    val = 10
    while True:
        if first < last:
            L[first] = val
            val += 10
            first += 1
            sleep(0.3)
        else:
            break


def from_right():
    global first, last, L
    val = "A"
    while True:
        if first < last:
            L[last] = val
            val = chr(ord(val) + 1)
            last -= 1
            sleep(0.3)
        else:
            break


size = 11  # <- Размер списка
L = ["*" for k in range(size)]  # <- Создание списка
# Начальный и конечный индексы
first = 0
last = len(L) - 1
print("Список до заполнения: ")
print(L)
# Создание объектов дочерних потоков
A = Thread(target=from_left())
B = Thread(target=from_right())
# Запуск потоков на выполнение
A.start()
B.start()
# Ожидание завершения потоков
A.join()
B.join()
# Результат заполнения списка
print("Списка после заполнения: ")
print(L)

# --------------------------------

# -- 10.17 Список с объектами дочерних потоков --


def mysum5(n ,N):  # <- Функция для вычисления суммы
    res = 0
    for k in range(N + 1):
        res += k ** n
        sleep(0.1)
    return res


def display5(n, N):  # <- Функция для выполнения в дочернем потоке
    mylock.acquire()  # <- Блокеровка объекта блокировки
    t = current_thread()  # <- Получение ссылки на текущий поток
    # Отображение имени потока
    print(f"Поток: {t.name}")
    print(f"Слагаемых: {N}")
    print(f"Степень: {n}")
    # Результат вычислений
    print(f"Сумма: {mysum5(n, N)}")
    print("-----------------------")
    mylock.release()  # <- Разблокирование объекта блокировки


mylock = Lock()  # <- Создание объекта блокировки
names = ["Alpha", "Bravo", "Charlie", "Delta"]  # <- Список с названиями потоков
# Создание списка с объектами потоков
T = [Thread(target=display5, args=[k + 1, 10], name=names[k]) for k in range(len(names))]
# Запуск потоков на выполнение
for t in T:
    t.start()
# Ожидание завершения выполнения потоков
for t in T:
    t.join()

# --------------------------------

